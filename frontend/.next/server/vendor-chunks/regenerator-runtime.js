"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regenerator-runtime";
exports.ids = ["vendor-chunks/regenerator-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */ \n!function(global1) {\n    \"use strict\";\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    var inModule = \"object\" === \"object\";\n    var runtime = global1.regeneratorRuntime;\n    if (runtime) {\n        if (inModule) {\n            // If regeneratorRuntime is defined globally and we're in a module,\n            // make the exports object identical to regeneratorRuntime.\n            module.exports = runtime;\n        }\n        // Don't bother evaluating the rest of this file if the runtime was\n        // already defined globally.\n        return;\n    }\n    // Define the runtime globally (as expected by generated code) as either\n    // module.exports (if we're in a module) or a new, empty object.\n    runtime = global1.regeneratorRuntime = inModule ? module.exports : {};\n    function wrap(innerFn, outerFn, self1, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []);\n        // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n        generator._invoke = makeInvokeMethod(innerFn, self1, context);\n        return generator;\n    }\n    runtime.wrap = wrap;\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n        try {\n            return {\n                type: \"normal\",\n                arg: fn.call(obj, arg)\n            };\n        } catch (err) {\n            return {\n                type: \"throw\",\n                arg: err\n            };\n        }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    IteratorPrototype[iteratorSymbol] = function() {\n        return this;\n    };\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n        // This environment has a native %IteratorPrototype%; use it instead\n        // of the polyfill.\n        IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n        [\n            \"next\",\n            \"throw\",\n            \"return\"\n        ].forEach(function(method) {\n            prototype[method] = function(arg) {\n                return this._invoke(method, arg);\n            };\n        });\n    }\n    runtime.isGeneratorFunction = function(genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    runtime.mark = function(genFun) {\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        } else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n            if (!(toStringTagSymbol in genFun)) {\n                genFun[toStringTagSymbol] = \"GeneratorFunction\";\n            }\n        }\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n    };\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    runtime.awrap = function(arg) {\n        return {\n            __await: arg\n        };\n    };\n    function AsyncIterator(generator) {\n        function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n            if (record.type === \"throw\") {\n                reject(record.arg);\n            } else {\n                var result = record.arg;\n                var value = result.value;\n                if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n                    return Promise.resolve(value.__await).then(function(value) {\n                        invoke(\"next\", value, resolve, reject);\n                    }, function(err) {\n                        invoke(\"throw\", err, resolve, reject);\n                    });\n                }\n                return Promise.resolve(value).then(function(unwrapped) {\n                    // When a yielded Promise is resolved, its final value becomes\n                    // the .value of the Promise<{value,done}> result for the\n                    // current iteration. If the Promise is rejected, however, the\n                    // result for this iteration will be rejected with the same\n                    // reason. Note that rejections of yielded Promises are not\n                    // thrown back into the generator function, as is the case\n                    // when an awaited Promise is rejected. This difference in\n                    // behavior between yield and await is important, because it\n                    // allows the consumer to decide what to do with the yielded\n                    // rejection (swallow it and continue, manually .throw it back\n                    // into the generator, abandon iteration, whatever). With\n                    // await, by contrast, there is no opportunity to examine the\n                    // rejection reason outside the generator function, so the\n                    // only option is to throw it from the await expression, and\n                    // let the generator function handle the exception.\n                    result.value = unwrapped;\n                    resolve(result);\n                }, reject);\n            }\n        }\n        if (typeof global1.process === \"object\" && global1.process.domain) {\n            invoke = global1.process.domain.bind(invoke);\n        }\n        var previousPromise;\n        function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n                return new Promise(function(resolve, reject) {\n                    invoke(method, arg, resolve, reject);\n                });\n            }\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n        // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n        this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    AsyncIterator.prototype[asyncIteratorSymbol] = function() {\n        return this;\n    };\n    runtime.AsyncIterator = AsyncIterator;\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    runtime.async = function(innerFn, outerFn, self1, tryLocsList) {\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self1, tryLocsList));\n        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n         : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n        });\n    };\n    function makeInvokeMethod(innerFn, self1, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n            if (state === GenStateExecuting) {\n                throw new Error(\"Generator is already running\");\n            }\n            if (state === GenStateCompleted) {\n                if (method === \"throw\") {\n                    throw arg;\n                }\n                // Be forgiving, per 25.3.3.3.3 of the spec:\n                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n                return doneResult();\n            }\n            context.method = method;\n            context.arg = arg;\n            while(true){\n                var delegate = context.delegate;\n                if (delegate) {\n                    var delegateResult = maybeInvokeDelegate(delegate, context);\n                    if (delegateResult) {\n                        if (delegateResult === ContinueSentinel) continue;\n                        return delegateResult;\n                    }\n                }\n                if (context.method === \"next\") {\n                    // Setting context._sent for legacy support of Babel's\n                    // function.sent implementation.\n                    context.sent = context._sent = context.arg;\n                } else if (context.method === \"throw\") {\n                    if (state === GenStateSuspendedStart) {\n                        state = GenStateCompleted;\n                        throw context.arg;\n                    }\n                    context.dispatchException(context.arg);\n                } else if (context.method === \"return\") {\n                    context.abrupt(\"return\", context.arg);\n                }\n                state = GenStateExecuting;\n                var record = tryCatch(innerFn, self1, context);\n                if (record.type === \"normal\") {\n                    // If an exception is thrown from innerFn, we leave state ===\n                    // GenStateExecuting and loop back for another invocation.\n                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                    if (record.arg === ContinueSentinel) {\n                        continue;\n                    }\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                } else if (record.type === \"throw\") {\n                    state = GenStateCompleted;\n                    // Dispatch the exception by looping back around to the\n                    // context.dispatchException(context.arg) call above.\n                    context.method = \"throw\";\n                    context.arg = record.arg;\n                }\n            }\n        };\n    }\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n        var method = delegate.iterator[context.method];\n        if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method always terminates the yield* loop.\n            context.delegate = null;\n            if (context.method === \"throw\") {\n                if (delegate.iterator.return) {\n                    // If the delegate iterator has a return method, give it a\n                    // chance to clean up.\n                    context.method = \"return\";\n                    context.arg = undefined;\n                    maybeInvokeDelegate(delegate, context);\n                    if (context.method === \"throw\") {\n                        // If maybeInvokeDelegate(context) changed context.method from\n                        // \"return\" to \"throw\", let that override the TypeError below.\n                        return ContinueSentinel;\n                    }\n                }\n                context.method = \"throw\";\n                context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n            }\n            return ContinueSentinel;\n        }\n        var record = tryCatch(method, delegate.iterator, context.arg);\n        if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        var info = record.arg;\n        if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value;\n            // Resume execution at the desired location (see delegateYield).\n            context.next = delegate.nextLoc;\n            // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n            if (context.method !== \"return\") {\n                context.method = \"next\";\n                context.arg = undefined;\n            }\n        } else {\n            // Re-yield the result returned by the delegate method.\n            return info;\n        }\n        // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n        context.delegate = null;\n        return ContinueSentinel;\n    }\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    Gp[toStringTagSymbol] = \"Generator\";\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    Gp[iteratorSymbol] = function() {\n        return this;\n    };\n    Gp.toString = function() {\n        return \"[object Generator]\";\n    };\n    function pushTryEntry(locs) {\n        var entry = {\n            tryLoc: locs[0]\n        };\n        if (1 in locs) {\n            entry.catchLoc = locs[1];\n        }\n        if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n        }\n        this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n    }\n    function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [\n            {\n                tryLoc: \"root\"\n            }\n        ];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n    }\n    runtime.keys = function(object) {\n        var keys = [];\n        for(var key in object){\n            keys.push(key);\n        }\n        keys.reverse();\n        // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n        return function next() {\n            while(keys.length){\n                var key = keys.pop();\n                if (key in object) {\n                    next.value = key;\n                    next.done = false;\n                    return next;\n                }\n            }\n            // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n            next.done = true;\n            return next;\n        };\n    };\n    function values(iterable) {\n        if (iterable) {\n            var iteratorMethod = iterable[iteratorSymbol];\n            if (iteratorMethod) {\n                return iteratorMethod.call(iterable);\n            }\n            if (typeof iterable.next === \"function\") {\n                return iterable;\n            }\n            if (!isNaN(iterable.length)) {\n                var i = -1, next = function next() {\n                    while(++i < iterable.length){\n                        if (hasOwn.call(iterable, i)) {\n                            next.value = iterable[i];\n                            next.done = false;\n                            return next;\n                        }\n                    }\n                    next.value = undefined;\n                    next.done = true;\n                    return next;\n                };\n                return next.next = next;\n            }\n        }\n        // Return an iterator with no values.\n        return {\n            next: doneResult\n        };\n    }\n    runtime.values = values;\n    function doneResult() {\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    Context.prototype = {\n        constructor: Context,\n        reset: function(skipTempReset) {\n            this.prev = 0;\n            this.next = 0;\n            // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n            if (!skipTempReset) {\n                for(var name in this){\n                    // Not sure about the optimal order of these conditions:\n                    if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n                        this[name] = undefined;\n                    }\n                }\n            }\n        },\n        stop: function() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n            if (rootRecord.type === \"throw\") {\n                throw rootRecord.arg;\n            }\n            return this.rval;\n        },\n        dispatchException: function(exception) {\n            if (this.done) {\n                throw exception;\n            }\n            var context = this;\n            function handle(loc, caught) {\n                record.type = \"throw\";\n                record.arg = exception;\n                context.next = loc;\n                if (caught) {\n                    // If the dispatched exception was caught by a catch block,\n                    // then let that catch block handle the exception normally.\n                    context.method = \"next\";\n                    context.arg = undefined;\n                }\n                return !!caught;\n            }\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                var record = entry.completion;\n                if (entry.tryLoc === \"root\") {\n                    // Exception thrown outside of any try block that could handle\n                    // it, so set the completion value of the entire function to\n                    // throw the exception.\n                    return handle(\"end\");\n                }\n                if (entry.tryLoc <= this.prev) {\n                    var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                    var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                    if (hasCatch && hasFinally) {\n                        if (this.prev < entry.catchLoc) {\n                            return handle(entry.catchLoc, true);\n                        } else if (this.prev < entry.finallyLoc) {\n                            return handle(entry.finallyLoc);\n                        }\n                    } else if (hasCatch) {\n                        if (this.prev < entry.catchLoc) {\n                            return handle(entry.catchLoc, true);\n                        }\n                    } else if (hasFinally) {\n                        if (this.prev < entry.finallyLoc) {\n                            return handle(entry.finallyLoc);\n                        }\n                    } else {\n                        throw new Error(\"try statement without catch or finally\");\n                    }\n                }\n            }\n        },\n        abrupt: function(type, arg) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                    var finallyEntry = entry;\n                    break;\n                }\n            }\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n                // Ignore the finally entry if control is not jumping to a\n                // location outside the try/catch block.\n                finallyEntry = null;\n            }\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n            if (finallyEntry) {\n                this.method = \"next\";\n                this.next = finallyEntry.finallyLoc;\n                return ContinueSentinel;\n            }\n            return this.complete(record);\n        },\n        complete: function(record, afterLoc) {\n            if (record.type === \"throw\") {\n                throw record.arg;\n            }\n            if (record.type === \"break\" || record.type === \"continue\") {\n                this.next = record.arg;\n            } else if (record.type === \"return\") {\n                this.rval = this.arg = record.arg;\n                this.method = \"return\";\n                this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) {\n                this.next = afterLoc;\n            }\n            return ContinueSentinel;\n        },\n        finish: function(finallyLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.finallyLoc === finallyLoc) {\n                    this.complete(entry.completion, entry.afterLoc);\n                    resetTryEntry(entry);\n                    return ContinueSentinel;\n                }\n            }\n        },\n        \"catch\": function(tryLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc === tryLoc) {\n                    var record = entry.completion;\n                    if (record.type === \"throw\") {\n                        var thrown = record.arg;\n                        resetTryEntry(entry);\n                    }\n                    return thrown;\n                }\n            }\n            // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n            throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function(iterable, resultName, nextLoc) {\n            this.delegate = {\n                iterator: values(iterable),\n                resultName: resultName,\n                nextLoc: nextLoc\n            };\n            if (this.method === \"next\") {\n                // Deliberately forget the last sent value so that we don't\n                // accidentally pass it on to the delegate.\n                this.arg = undefined;\n            }\n            return ContinueSentinel;\n        }\n    };\n}(// Among the various tricks for obtaining a reference to the global\n// object, this seems to be the most reliable technique that does not\n// use indirect eval (which violates Content Security Policy).\ntypeof global === \"object\" ? global :  false ? 0 : typeof self === \"object\" ? self : void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBRUQsQ0FBQyxTQUFVQSxPQUFNO0lBQ2Y7SUFFQSxJQUFJQyxLQUFLQyxPQUFPQyxTQUFTO0lBQ3pCLElBQUlDLFNBQVNILEdBQUdJLGNBQWM7SUFDOUIsSUFBSUMsV0FBVyxpQ0FBaUM7SUFDaEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGFBQWFBLFNBQVMsQ0FBQztJQUN2RCxJQUFJQyxpQkFBaUJGLFFBQVFHLFFBQVEsSUFBSTtJQUN6QyxJQUFJQyxzQkFBc0JKLFFBQVFLLGFBQWEsSUFBSTtJQUNuRCxJQUFJQyxvQkFBb0JOLFFBQVFPLFdBQVcsSUFBSTtJQUUvQyxJQUFJQyxXQUFXLFFBQWFDLEtBQUs7SUFDakMsSUFBSUMsVUFBVWpCLFFBQU9rQixrQkFBa0I7SUFDdkMsSUFBSUQsU0FBUztRQUNYLElBQUlGLFVBQVU7WUFDWixtRUFBbUU7WUFDbkUsMkRBQTJEO1lBQzNEQyxPQUFPRyxPQUFPLEdBQUdGO1FBQ25CO1FBQ0EsbUVBQW1FO1FBQ25FLDRCQUE0QjtRQUM1QjtJQUNGO0lBRUEsd0VBQXdFO0lBQ3hFLGdFQUFnRTtJQUNoRUEsVUFBVWpCLFFBQU9rQixrQkFBa0IsR0FBR0gsV0FBV0MsT0FBT0csT0FBTyxHQUFHLENBQUM7SUFFbkUsU0FBU0MsS0FBS0MsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLEtBQUksRUFBRUMsV0FBVztRQUMvQyx5R0FBeUc7UUFDekcsSUFBSUMsaUJBQWlCSCxXQUFXQSxRQUFRbkIsU0FBUyxZQUFZdUIsWUFBWUosVUFBVUk7UUFDbkYsSUFBSUMsWUFBWXpCLE9BQU8wQixNQUFNLENBQUNILGVBQWV0QixTQUFTO1FBQ3RELElBQUkwQixVQUFVLElBQUlDLFFBQVFOLGVBQWUsRUFBRTtRQUUzQyxnRUFBZ0U7UUFDaEUsK0JBQStCO1FBQy9CRyxVQUFVSSxPQUFPLEdBQUdDLGlC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OEQ7QUFDOUQsT0FBTzVDLFdBQVcsV0FBV0EsU0FDN0IsTUFBMEIsR0FBR2dKLENBQU1BLEdBQ25DLE9BQU96SCxTQUFTLFdBQVdBLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP2M1NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiT3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiaW5Nb2R1bGUiLCJtb2R1bGUiLCJydW50aW1lIiwicmVnZW5lcmF0b3JSdW50aW1lIiwiZXhwb3J0cyIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInNlbGYiLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiY3JlYXRlIiwiY29udGV4dCIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJvYmoiLCJhcmciLCJ0eXBlIiwiY2FsbCIsImVyciIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImNvbnN0cnVjdG9yIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJ2YWx1ZSIsIlByb21pc2UiLCJ0aGVuIiwidW53cmFwcGVkIiwicHJvY2VzcyIsImRvbWFpbiIsImJpbmQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsIml0ZXIiLCJuZXh0IiwiZG9uZSIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJldHVybiIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInRvU3RyaW5nIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsImVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicHVzaCIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJrZXlzIiwib2JqZWN0Iiwia2V5IiwicmV2ZXJzZSIsImxlbmd0aCIsInBvcCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImkiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/regenerator-runtime/runtime.js\n");

/***/ })

};
;